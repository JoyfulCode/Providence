At its core, it's basically a dependency-management system. There's a set of nodes and a set of dependencies between them, forming a directed acyclic graph. Each edge corresponds with a particular action that generates the target object of a node from its sources. Given a set of target products, the dependency system computes a partial ordering of actions to be run in order to generate these products. This is the essence of the system; everything else is just icing.

Nodes don't necessarily have to be files, though it's expected that in the most common use cases, this will be the case. Similarly, actions don't have to be shell commands (they can be D functions, for example), though that is also the most common use case. Being the most common use cases, we should optimize for files / shell commands in the implementation, but the possibility of non-file nodes and non-shell actions should be supported, and shoudn't be unduly hampered just because they're not the common case.

Actions may be elided if its target has already been previously built, and none of its sources have changed since the last build. The success of the system pretty much depends on how effectively we can perform this elision, while still ensuring that out-of-date products must be rebuilt.

Although this isn't the core system, it's pretty important to allow the dependency graph to be implicitly specified, i.e., the user shouldn't be expected to manually specify every node and every command. Where possible, dependencies should be automatically inferred by various means. There should be a set of prebaked tools to automatically extract dependencies for common targets, e.g., compiling source code into object files / binaries. This is separate from the core system, but should still be bundled with the overall system so that users can just plop it in and get going, while specifying only the minimal necessary information. I envision this to be a kind of user-extensible library of "build rules" that includes all the commonly-needed builds, perhaps with an optional repository of rarer but still widespread rules. The user should have direct access to the library infrastructure, so that they can build custom rules that work with the same level of efficiency and integration as the "standard library" rules.

Some way(s) of detecting whether a node is outdated would have to be considered. Ideally, we shouldn't have to scan every node to detect if something has changed; to the extent possible, we should leverage notification services (e.g., inotify) from the OS to detect changes. Of course, this isn't always possible, in which case there should be fallback methods for detecting change. Again, the infrastructure should be made available to users, so that they can implement their own notification tools if they so see fit.

Some other miscellaneous notes:

The system shouldn't require the explicit construction of the entire dependency graph if the current user request doesn't need it. E.g., if my workspace has code for 5 binaries, and I only ask to build one of them, the system only needs to know that subset of the entire graph pertinent to that particular binary. The system should be designed in such a way that it can work correctly while knowing only a subgraph of the entire graph, and it only needs to create that part of the graph that is required to perform the requested task.

