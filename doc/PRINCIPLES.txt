
Reliability - The user must be able to trust that the system works as intended. Behavior is either defined or prohibited. Undefined behavior is disallowed to the extent possible, or where this is not possible it is reported. The system should be self-healing in the face of unanticipated changes (such as inputs which were not explicitly specified, or transient circular dependencies due to implied changes in the dependency graph.)

Reproduce-ability - If a workflow is executed with a given set of inputs and environment, re-executing the workflow with the same inputs and environment will produce the same results. If this is not possible, the exceptions are made explicit and the user is informed.

Incremental Scalability - The system is designed to work for the single user and provide measurable benefit. The system can be scaled up as needed but does not require simple use cases to take on the burden of higher-scale systems, such as provisioning for distribution or setting up additional services. The workflow should perform relative to the amount of work needed to provide a given output, not according to the overall size of the graph.

Pay As You Go - Resources and setup are only needed for the features the user needs. Complexity is restricted to only those features requested by the user.

Interoperability - To the extent possible, leverage existing tools and formats rather than explicitly requiring the user to convert everything to gain the benefit of the system. For example, if the user has a functioning build system expressed with a makefile, we would like the system to be able to either consume that directly, or have there be some mostly/entirely automated way of converting to a more useful format. Existing tools such as compilers, linkers and other tools should "just work", and any deficiencies they have with regards to the Reliability and Reproduceability principles should be reported to the user to be addressed, with an option of working around them or degrading those principles - again with full user knowledge and consent. An ideal world is usually not possible, but users don't always need an ideal world - if they do, they can invest in tooling which meets those needs incrementally. NOTE this does NOT strictly imply round-tripping (the ability to seamlessly move from a new format or tool back to an old format or tool and vice-versa.)

Performance - The system is designed to use resources efficiently. Only the work which must be done to satisfy the user's request should be done immediately, and other work can be deferred. If the work has been done before, the previous results are used if available. The user's perception of performance is also important - anticipating work or optimistically doing work so that the user's question can be answered immediately when they ask it are potentially valid strategies assuming that such work doesn't negatively affect other aspects of the workflow. Interrupting and aborting work which is determined to no longer be useful should be baked into the various feature areas.

Minimal Specification - The user should only have to supply the minimum amount of information for the system to construct a graph with the correct nodes, and ordering from there should be inferred and self-maintained to the extent possible. The user should have the option to dial this up to fully-specified graphs where only those dependencies the user allows may be entered into the graph and all other detected dependencies are errors.

Extensible/Composable - The system should have well-defined and maintained extensibility points. Ideally, the extensibility system is the system by which interactions are defined, such that this project dogfoods the extensibility system during development. User-provided extensions are treated as first-class citizens by the ecosystem - there are no hidden APIs or functionality. If possible, I would like extensibility to be enabled using common languages such as Lua, Python, etc. in addition to binary extensibility. The support of such languages can itself be through an extensibility point (plug-in host.)

Portable - The tooling for this project ideally works on the Big Three platforms (Windows, Linux, Mac OSX), and the behavior is the same on all of the platforms.

Distributable - The work generated by the dependency graph can be done on any machine running a suitable client, with the environment for the work being fully controlled by the build system as specified by the user. This includes sanitizing file system and other OS call access, remoting initial sources, tools and produced binaries, and otherwise automatically maintaining the system. The user should only have to do the most minimal of setup to add a worker node to the system (equivalent to running a binary at the root of some directory and telling it where the master is.)

Comprehensible - The system should be easily understood by the user. Logging should be explicit and useful. The system should be amenable to introspection such as through graph viewers or other tooling for analysis. Ideally the user can interact with the system largely or entirely through a simple command-line interface and text editor.

